<p>Euler Cycles<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />Motivation : Genome Assembly Program &rarr; Given a set S = 3-perm({A,T,C,G}, find a string s = w₁w₂..wᵣ, s.t., wᵢ &isin; S, &forall; wᵢ</p>
<p>Defⁿ: Given G = (V,E), an Eulerian Cycle E(G), is a cycle Cᵢ, s.t., |Cᵢ| = |E|</p>
<p>Thᵐ : Given G = (V,E), st, G is connected and undirected, &exist; E(G) &hArr; &forall; v &isin; V(G) , deg(v) = Even<br />Proof : We split it into 2 cases -<br /> a) Given : G =(V,E), s.t., G has E(G)<br /> Then, let's assume that &exist; v &isin; V(G) s.t., deg(v) = odd.<br /> Clearly, when v is traversed in E(G), everytime it is "approached", it must be "left". However, the odd degree implies that there will be one edge that cannot<br /> be traversed as a result of no unvisited edges that can be left from. Hence, &exist; edge e = (v, v'), s.t., e &notin; E(G). This is a contradiction. Therefore, deg(v) = Even</p>
<p>b) Given : G=(V,E) s.t., &forall; v &isin; V(G), dev(v) = Even<br /> Pick some v &isin; V(G). Start on an outside Random Walk from this. Let w = v₁v₂..vᵢ, until you hit v₁ = vᵢ, and |w| &lt; |E|. Then &exist; vᵢ' &isin; w, s.t., vᵢ' has an unexplored<br /> out edge. Start a new walk and repeat this procedure. On intersecting vertices on walks wₐ and wⱼ, we can union the 2 cycles to create a new one. This way, when we<br /> have fully explored all the edges, and unioned all intersecting walks, we end up with an Eulerian Cycle</p>
<p>QED</p>
<p>Note: An Eulerian Path Eⱼ(G) = v₁...vⱼ....vᵢ can be extended to an Eulerian Cycle E(G) = v₁...vⱼ...vᵢv₁, by making E = E &cup; {vᵢ,v₁}</p>
<p>&rarr; Part b) of the proof the Thᵐ shows that &exist; an Efficient Algorithm A, s.t., A can compute the Eulerian Cycle of G</p>
<p><br />Hamiltonian Cycles<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />Motivation : Goal is to traverse the Graph and visit every vertex just once, not only every edge</p>
<p>Defⁿ: A simple Euler Cycle, i.e., H(G) = simple(E(G))</p>
<p>Thᵐ : Given G = (V,E), finding H(G) is NP-Complete</p>
<p><br />Genome Assembly<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;<br />Construction : Hamiltonian Cycle over a Graph G = (V,E), where, V = (S = 3-perm{A,T,C,G}) &and; E = {(vᵢ,vⱼ) | suffix(vᵢ) = 2-prefix(vⱼ)}<br />Solⁿ : Find a Hamiltonian Path over this graph setup &rarr; NP-Complete</p>
<p>Idea : See, if we can reduce the Genome Problem in Poly(|S|) time to a problem P, s.t., P &notin; NP-Complete<br /> i) Try reducing to a De-Brujin Graph DBG, where, an edge represents a valid sᵢ &isin; S.<br /> ii) So - &forall; sᵢ , sᵢ &rarr; (vᵢ,vⱼ), where vᵢ = 2-prefix(sᵢ) and vⱼ = 2-suffix(sⱼ)<br /> iii) Now, in order to find a string s = w₁w₂....wᵢ , s.t., we simply construct an Eulerian Cycle.<br /> a) wᵢ = perm(A,T,C,G), wⱼ = perm'(A,T,C,J)<br /> b) word(wᵢwⱼ) = perm(A,T,C,G) &cup; perm'(A,T,C,G) = (vᵢ, vⱼ) &isin; E<br /> c) By induction, as every edge represents one 3-perm, going over all edges represents a valid 3-perm string concatenation</p>
